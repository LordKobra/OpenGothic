#version 460

//#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_shader_image_load_formatted : require 

#include "scene.glsl"
#include "common.glsl" 

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, std140) uniform   UboScene {
  SceneDesc scene;
  };
layout(binding = 1) uniform           sampler2D zbuffer;
layout(binding = 2) uniform           texture2D in_color;
layout(binding = 3) uniform writeonly image2D   out_color;
layout(binding = 4) uniform           sampler2D waterCaustic;
layout(binding = 5) uniform           sampler2D waterCausticHR;

layout(push_constant, std140) uniform PushConstant {
  float waterHeight;
  } push;
// fixme: copy-paste
vec4 waterScatter(vec3 normal,vec3 camPos, vec3 wPos, vec3 color) {
  // convert to meter
  const float surface_pos = push.waterHeight / 100.0; // here we require the last tracked water intersection from the camera
  const vec3  sunDir = scene.sunDir / 100.0;
  const vec3  dir         = wPos-camPos;
  const float len         = length(dir);
  const float depth       = len; // 1 = 1m
  const vec3  ndir        = dir/length(dir);
  const float angle = 1.0 - acos(ndir.y) / M_PI;

  const float camera_depth = (surface_pos-camPos.y);
  float surface_depth = (surface_pos-wPos.y);
  surface_depth = surface_depth < 0.0 ? 0.0 : surface_depth;
  // some assumptions:
  // 700 nm (red), 546.1 nm (green) and 435.8 nm (blue)
  // clear ocean water https://opg.optica.org/ao/fulltext.cfm?uri=ao-20-2-177&id=24568
  const vec3 c_ocean = vec3(0.65, 0.06, 0.024);
  const vec3 c_clear = vec3(0.65, 0.073, 0.047);
  const vec3 c = c_clear;
  const vec3 posSurfTransmittance = exp(-(surface_depth * c));
  const vec3 posCamTransmittance = exp(-(depth * c));

  // back color transmittance
  // Note: calculate reflectance lux loss before entering water (fresnel)
  // Note: Sun currently not visible while underwater (bug)
  // Note: add caustics
  // Todo: Make caustic texture a sampler
  // Todo: Check normals to reduce effect from below: or check sunlight
  // Todo: Rework pos-surf transmittance to account for sunlight direction

  const vec3 surface_sunpos = wPos.xyz + sunDir.xyz * surface_depth / abs(sunDir.y);
  const float surface_sunpos_dist = length(surface_sunpos-wPos.xyz);
  const vec3 posSunTransmittance = exp(-(surface_sunpos_dist * c));
  vec3 caustic = texture(waterCaustic, vec2(surface_sunpos.xz * 0.05)).rgb;
  caustic      = 0.66+13*caustic;
  caustic      = surface_depth < 1.0 ? surface_depth * caustic + (1-surface_depth).xxx : caustic;
  //caustic      = gl_GlobalInvocationID.x > 2000 ? vec3(1) : caustic;

  const vec3 background_transmittance = color * posSunTransmittance * posCamTransmittance * scene.sunColor * scene.exposure * caustic;

  // scatter
  // Note: flat water gradient looked better with high scatter mult / deep with final mult
  // Note: cone shaped variant ends up with 1/3 height (ambient)
  // Note: add sun scatter + refraction, separate ambient scatter
  // Note: use correct light values, check exposure
  // Note: Check diffuse downdwelling coefficient to replace scatter_mult:
  //       https://onlinelibrary.wiley.com/doi/10.1111/cgf.15009
  // Note: extend scatter into ddy noise texture sampling for godrays
  const float scatter_mult = 3.0;
  const float v = ndir.y == 0 ? -0.001 : -ndir.y * scatter_mult;
  const float x = depth;
  const float h_1 = camera_depth * scatter_mult;
  vec3 scatter_intensity = -exp(-c * (v * x + x + h_1));
  scatter_intensity     +=  exp(-c * h_1);
  scatter_intensity     /= c * v + c;
  const vec3 scatter_light = scene.ambient * scene.exposure * 0.2 * scatter_intensity;

  // sunray scatter
  // make it move in texture steps instead of world steps
  vec3 accum_sunrays = vec3(0.0);
  int total_accum = 1;
  for(int i = 20; i < 100; i++){
    float sample_dist = 0.4 * i; // meter
    if(sample_dist >= len) break;
    vec3 current_pos                        = camPos+ndir*sample_dist;
    float current_depth                     = (surface_pos-current_pos.y);
    vec3 current_surface_sunpos             = current_pos.xyz + sunDir.xyz * current_depth / abs(sunDir.y);
    float current_surface_sunpos_dist       = length(current_surface_sunpos-current_pos.xyz);
    vec3 current_caustic                    = texture(waterCausticHR, vec2(current_surface_sunpos.xz * 0.05)).rgb;
    accum_sunrays                          += current_caustic * exp(-c*(current_surface_sunpos_dist+sample_dist)); 
    total_accum += 1;
    }
    accum_sunrays *= scene.sunColor * scene.exposure * (1.0/total_accum);

  // const float v2 = ndir.y == 0 ? -0.001 : -ndir.y;
  // const float h_2 = camera_depth; // * sundir
  // vec3 scatter_intensity = -exp(-c * (v * x + x + h_1));
  // scatter_intensity     +=  exp(-c * h_1);
  // scatter_intensity     /= c * v + c;
  // const vec3 scatter_light = scene.ambient * scene.exposure * 0.2 * scatter_intensity;

  // ambient
  const vec3 posCamAmbTransmittance = exp(-(3 * depth * vec3(0.15,0.10,0.05)));
  const vec3 ambient_transmittance = color * posCamAmbTransmittance;

  return vec4(background_transmittance+scatter_light+accum_sunrays, 1.0);
  }

vec3 unproject(vec4 screen) {
  const vec4 pos4 = scene.viewProjectInv * screen;
  return pos4.xyz/pos4.w;
  }

void main(){
  const ivec2 pos = ivec2(gl_GlobalInvocationID.xy);

  const vec2  ndcPos    = (pos.xy * scene.screenResInv) * 2.0 - vec2(1.0);
  const float depth     = texelFetch(zbuffer,  pos, 0).r;

  // in m
  const vec3  camPos    = unproject(vec4(0.0, 0.0, 0.0, 1.0)) / 100.0;
  const vec3  wPos      = unproject(vec4(ndcPos.x, ndcPos.y, depth, 1.0)) / 100.0;

  //const vec3 wDir = wPos-camPos;
  //const float len = length(wPos-camPos);

  vec3 color = texelFetch(in_color, pos, 0).rgb;
  color = waterScatter(vec3(0.0 ,1.0 ,0.0), camPos, wPos, color).rgb;
  imageStore(out_color, pos, vec4(color,1.0));

 }